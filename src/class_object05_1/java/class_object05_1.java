package class_object05_1.java;

public class class_object05_1 {
    public static void main(String[] args) {

        //继承性
        /*
        继承性的好处：
            继承的出现减少了代码冗余，提高了代码的复用性
            继承的出现，更有利于功能的扩展
            继承的出现让类与类之间产生了关系，提供了多态的前提
        语法规则：class Subclass extends SuperClass{}
            子类继承后获取到父类所有声明的属性和方法
            子类不能直接访问父类中私有的（private）的成员变量和方法（也继承了）（封装性）
        Java只支持单继承和多层继承，不允许多重继承
            一个子类只能有一个父类
            一个父类可以派生出多个子类


        Object类
            如果没有显式声明继承一个类，则此类继承于java.lang.Object类
            所有java类都直接或间接继承于java.lang.Object类（自己除外）





         */
        Person p1=new Person();
        p1.age=1;
        p1.eat();

        Student s1=new Student();
        s1.eat();

        //方法的重写
        /*
        定义
            在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。
        重写的要求：
            子类重写的方法必须和父类被重写的方法具有相同的方法名称、形参列表
            子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限（private->...->public）
                private权限的方法不能被重写（特殊情况）
            子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
                父类             子类
                void             void
                A类              A类或者A的子类
                基本数据类型      相同数据类型

            子类方法抛出的异常不能大于父类被重写方法的异常（后续学习）
            子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。
            因为static方法是属于类的，子类无法覆盖父类的方法。（后续学习）

         */
        s1.walk(10);


        //四种权限修饰符
        /*
        修饰符       类内部    同一个包   不同包的子类    同一个工程
        private      yes
        default      yes      yes
        protected    yes      yes        yes
        public       yes      yes        yes           yes
        修饰类的，只能用default和public
        public类可以在任意地方被访问
        default类只可以被同一个包内部的类访问




         */

        System.out.println("***********");
        //关键字super
        /*
        在子类的方法或构造器中，使用super.属性/super.方法显式调用（习惯省略）
        子父类同名属性时，必须使用super.属性表明调用的是父类声明的属性
        子类重写了父类的方法后，必须使用super.方法表明是父类中被重写的方法

         */
        Person p2=new Person();
        p2.eat();

        Student s2=new Student();
        s2.study();//调用父类的方法

        /*
        在子类的构造器中使用super（形参列表）的方式，调用父类声明的指定的构造器
        super（形参列表）的使用，必须放在首行
        this（形参列表）也在首行，只能二选一
        都不加时，默认是super（）；
        如果子类构造器中既未显式调用父类或本类的构造器且父类中又没有无参的构造器，则编译出错（缺少super（）空参构造器）
        类的多个构造器，至少有一个为super（）
         */  //调用父类的构造器




        System.out.println("***********");
        //多态性
        /*
        对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）
        编译期调用父类的方法，执行期调用子类重写父类的方法

        多态性的使用前提：
            类的继承关系
            方法的重写

        对象的多态性不适用于属性，只适用于方法（编译运行都看左边）

         */
        Person p3=new Student();//对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）
        p3.eat();//多态的使用：当调用子父类同名函数时，实际执行的是子类重写父类的方法---虚拟方法调用
//        p3.study();//无法调用子类特有的方法
        //编译看左，运行看右







    }



}


